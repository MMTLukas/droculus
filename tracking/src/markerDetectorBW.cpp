
////////////////////////////////////////////////////////////////////
// Standard includes:
#include <iostream>
#include <sstream>

////////////////////////////////////////////////////////////////////
// File includes:
#include "include/markerDetectorBW.hpp"
#include "include/markerBW.hpp"

using namespace std;

#define SHOW_DEBUG_IMAGES

MarkerDetectorBW::MarkerDetectorBW(cv::Mat cameraMatrix, cv::Mat distCoeffs, float marker3DWidth, float marker3DHeight)
    : _minContourLengthAllowed(100)
    , markerImageSize(100,100)
{
    camMatrix = cameraMatrix;
    distCoeff = distCoeffs;

    bool centerOrigin = true;
    if (centerOrigin)
    {
        _markerCorners3d.push_back(cv::Point3f(-0.5f * marker3DWidth, -0.5f * marker3DHeight, 0));
        _markerCorners3d.push_back(cv::Point3f(+0.5f * marker3DWidth, -0.5f * marker3DHeight, 0));
        _markerCorners3d.push_back(cv::Point3f(+0.5f* marker3DWidth, +0.5f * marker3DHeight, 0));
        _markerCorners3d.push_back(cv::Point3f(-0.5f* marker3DWidth, +0.5f * marker3DHeight, 0));
    }
    else
    {
        _markerCorners3d.push_back(cv::Point3f(0,0,0));
        _markerCorners3d.push_back(cv::Point3f(marker3DWidth, 0, 0));
        _markerCorners3d.push_back(cv::Point3f(marker3DWidth, marker3DHeight, 0));
        _markerCorners3d.push_back(cv::Point3f(0, marker3DHeight, 0));
    }

    _markerCorners2d.push_back(cv::Point2f(0,0));
    _markerCorners2d.push_back(cv::Point2f(markerImageSize.width-1,0));
    _markerCorners2d.push_back(cv::Point2f(markerImageSize.width-1,markerImageSize.height-1));
    _markerCorners2d.push_back(cv::Point2f(0,markerImageSize.height-1));

#ifdef SHOW_DEBUG_IMAGES
    cv::namedWindow("01 Threshold image", CV_WINDOW_NORMAL);
    cv::namedWindow("02 Contours", CV_WINDOW_NORMAL);
    cv::namedWindow("03 Source marker", CV_WINDOW_NORMAL);
    cv::namedWindow("04 MarkerBW after warp", CV_WINDOW_NORMAL);
    cv::namedWindow("05 Markers refined edges", CV_WINDOW_NORMAL);
#endif

}

void MarkerDetectorBW::processFrame(const cv::Mat& frame)
{
    std::vector<MarkerBW> markers;
    findMarkers(frame, markers);

    _transformations.clear();
    for (size_t i=0; i<markers.size(); i++)
    {
        _transformations.push_back(markers[i].pose);
    }
}

const std::vector<Pose>& MarkerDetectorBW::getPoses() const
{
    return _transformations;
}


bool MarkerDetectorBW::findMarkers(const cv::Mat& frame, std::vector<MarkerBW>& detectedMarkers)
{
    // Convert the image to grayscale
    prepareImage(frame, _grayscaleImage);

    // Make it binary
    performThreshold(_grayscaleImage, _thresholdImg);

    // Detect contours
    // we want to ensure that we discard very small contours, hence the minimum length is image height / 5 -->  ~ 100 px
    findContours(_thresholdImg, _contours, _grayscaleImage.cols / 5);

    // Find closed contours that can be approximated with 4 points
    findCandidates(_contours, detectedMarkers);

    // Find is them are markers
    recognizeMarkers(_grayscaleImage, detectedMarkers);

    // Calculate their poses
    estimatePosition(detectedMarkers);

    //sort by id
    std::sort(detectedMarkers.begin(), detectedMarkers.end());
    return false;
}

void MarkerDetectorBW::prepareImage(const cv::Mat& bgraMat, cv::Mat& grayscale) const
{
    // Convert to grayscale
    cv::cvtColor(bgraMat, grayscale, CV_BGRA2GRAY);

}

void MarkerDetectorBW::performThreshold(const cv::Mat& grayscale, cv::Mat& thresholdImg) const
{
    /// STUDENT TODO: perform thresholding
    cv::threshold(grayscale,thresholdImg, 127, 255, cv::THRESH_BINARY);

    // SECTION START
    /// STUDENT TODO: uncomment section after thresholding
#ifdef SHOW_DEBUG_IMAGES
    cv::imshow("01 Threshold image", thresholdImg);
#endif
    // SECTION END

}

void MarkerDetectorBW::findContours(cv::Mat& thresholdImg, ContoursVector& contours, int minContourPointsAllowed) const
{
    if (thresholdImg.empty()) return;
    ContoursVector allContours;

    /// STUDENT TODO: find contours (without establishing hierarchical relationships, without chain approximation)

    cv::findContours(thresholdImg, allContours, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);

    contours.clear();
    for (size_t i=0; i<allContours.size(); i++)
    {
        int contourSize = allContours[i].size();
        //cout << "contourSize: " << contourSize << endl;
        if (contourSize > minContourPointsAllowed)
        {
            contours.push_back(allContours[i]);
        }
    }

#ifdef SHOW_DEBUG_IMAGES
    {
        cv::Mat contoursImage(thresholdImg.size(), CV_8UC1);
        contoursImage = cv::Scalar(0);
        cv::drawContours(contoursImage, contours, -1, cv::Scalar(255), 2, CV_AA);
        cv::imshow("02 Contours", contoursImage);
    }
#endif
}

void MarkerDetectorBW::findCandidates(const ContoursVector& contours,  std::vector<MarkerBW>& detectedMarkers)
{
    std::vector<cv::Point>  approxCurve;  // the approximated curve generated by approxPolyDP
    std::vector<MarkerBW>     possibleMarkers;

    // For each contour, analyze if it is a parallelepiped likely to be the marker
    for (size_t i=0; i<contours.size(); i++)
    {

        double polygonEpsilon = contours[i].size() * 0.05;
        /// STUDENT TODO: Approximate to a polygon
        cv::approxPolyDP(contours[i], approxCurve, polygonEpsilon, true);
        /// STUDENT TODO: check if polygon has only four corners
        if(approxCurve.size() != 4)
            continue;
        /// STUDENT TODO: check if polygon is convex
        if(!cv::isContourConvex(approxCurve))
            continue;
        ///// STUDENT TODO remove break after implementing checks above
        //break;

        // Ensure that the distance between consecutive points is large enough
        float minDist = std::numeric_limits<float>::max();

        for (int i = 0; i < 4; i++)
        {
            cv::Point side = approxCurve[i] - approxCurve[(i+1)%4];
            float squaredSideLength = side.dot(side);
            minDist = std::min(minDist, squaredSideLength);
        }

        // Check that distance is not very small
        if (minDist < _minContourLengthAllowed)
            continue;

        // All tests are passed. Save marker candidate:
        MarkerBW m;

        for (int i = 0; i<4; i++)
            m.points.push_back( cv::Point2f(approxCurve[i].x,approxCurve[i].y) );

        // Sort the points in anti-clockwise order
        // Trace a line between the first and second point.
        // If the third point is at the right side, then the points are anti-clockwise
        cv::Point v1 = m.points[1] - m.points[0];
        cv::Point v2 = m.points[2] - m.points[0];

        double o = (v1.x * v2.y) - (v1.y * v2.x);

        if (o < 0.0)		 //if the third point is in the left side, then sort in anti-clockwise order
            std::swap(m.points[1], m.points[3]);

        possibleMarkers.push_back(m);
    }

    // Remove these elements which corners are too close to each other.
    // First detect candidates for removal:
    std::vector< std::pair<int,int> > tooNearCandidates;
    for (size_t i=0; i<possibleMarkers.size(); i++)
    {
        const MarkerBW& m1 = possibleMarkers[i];

        //calculate the average distance of each corner to the nearest corner of the other marker candidate
        for (size_t j=i+1; j<possibleMarkers.size(); j++)
        {
            const MarkerBW& m2 = possibleMarkers[j];

            float distSquared = 0;

            for (int c = 0; c < 4; c++)
            {
                cv::Point v = m1.points[c] - m2.points[c];
                distSquared += v.dot(v);
            }

            distSquared /= 4;

            if (distSquared < 100)
            {
                tooNearCandidates.push_back(std::pair<int,int>(i,j));
            }
        }
    }

    // Mark for removal the element of the pair with smaller perimeter
    std::vector<bool> removalMask (possibleMarkers.size(), false);

    for (size_t i=0; i<tooNearCandidates.size(); i++)
    {
        float p1 = perimeter(possibleMarkers[tooNearCandidates[i].first ].points);
        float p2 = perimeter(possibleMarkers[tooNearCandidates[i].second].points);

        size_t removalIndex;
        if (p1 > p2)
            removalIndex = tooNearCandidates[i].second;
        else
            removalIndex = tooNearCandidates[i].first;

        removalMask[removalIndex] = true;
    }

    // Return candidates
    detectedMarkers.clear();
    for (size_t i=0; i<possibleMarkers.size(); i++)
    {
        if (!removalMask[i])
            detectedMarkers.push_back(possibleMarkers[i]);
    }
}

void MarkerDetectorBW::recognizeMarkers(const cv::Mat& grayscale, std::vector<MarkerBW>& detectedMarkers)
{
    std::vector<MarkerBW> goodMarkers;
    std::vector<cv::Point2f> transMat;

    // Identify the markers
    for (size_t i = 0; i < detectedMarkers.size(); i++)
    {
        MarkerBW& marker = detectedMarkers[i];

        /// STUDENT TODO: Find the perspective transformation that brings current marker to rectangular form
        cv::Mat result = cv::getPerspectiveTransform(detectedMarkers[i].points, _markerCorners2d);

        /// STUDENT TODO: Transform image to get a canonical marker image
        cv::warpPerspective(grayscale, _canonicalMarkerImage, result, markerImageSize);

        if (_canonicalMarkerImage.empty() == false)
        {
#ifdef SHOW_DEBUG_IMAGES
            {
                cv::Mat markerImage = grayscale.clone();
                marker.drawContour(markerImage);
                cv::Mat markerSubImage = markerImage(cv::boundingRect(marker.points));

                cv::imshow("03 Source marker", markerSubImage);
                cv::imshow("04 MarkerBW after warp", _canonicalMarkerImage);
            }
#endif

            int nRotations;
            int id = MarkerBW::getMarkerBWId(_canonicalMarkerImage, nRotations);
            if (id != -1)
            {
                marker.id = id;
                //sort the points so that they are always in the same order no matter the camera orientation
                std::rotate(marker.points.begin(), marker.points.begin() + 4 - nRotations, marker.points.end());

                goodMarkers.push_back(marker);
            }
        }
    }

    // Refine marker corners using sub pixel accuracy
    if (goodMarkers.size() > 0)
    {
        std::vector<cv::Point2f> preciseCorners(4 * goodMarkers.size());

        for (size_t i=0; i<goodMarkers.size(); i++)
        {
            const MarkerBW& marker = goodMarkers[i];

            for (int c = 0; c <4; c++)
            {
                preciseCorners[i*4 + c] = marker.points[c];
            }
        }

        cv::TermCriteria termCriteria = cv::TermCriteria(cv::TermCriteria::MAX_ITER | cv::TermCriteria::EPS, 30, 0.01);
        cv::cornerSubPix(grayscale, preciseCorners, cvSize(5,5), cvSize(-1,-1), termCriteria);

        // Copy refined corners position back to markers
        for (size_t i=0; i<goodMarkers.size(); i++)
        {
            MarkerBW& marker = goodMarkers[i];

            for (int c=0; c<4; c++)
            {
                marker.points[c] = preciseCorners[i*4 + c];
            }
        }
    }

#ifdef SHOW_DEBUG_IMAGES
    {
        cv::Mat markerCornersMat(grayscale.size(), grayscale.type());
        markerCornersMat = cv::Scalar(0);

        for (size_t i=0; i<goodMarkers.size(); i++)
        {
            goodMarkers[i].drawContour(markerCornersMat, cv::Scalar(255));
        }

        cv::imshow("05 Markers refined edges", grayscale * 0.5 + markerCornersMat);
    }
#endif
    detectedMarkers = goodMarkers;
}


void MarkerDetectorBW::estimatePosition(std::vector<MarkerBW>& detectedMarkers)
{
    //std::cout << "detected markers: " << detectedMarkers.size() << endl;
    for (size_t i=0; i<detectedMarkers.size(); i++)
    {
        MarkerBW& m = detectedMarkers[i];

        cv::Mat Rvec;
        cv::Mat_<float> Tvec;
        cv::Mat raux,taux;

        /// STUDENT TODO: compute pose
        cv::solvePnP(_markerCorners3d, m.points, camMatrix, distCoeff, raux, taux);

        // SECTION START
        /// STUDENT TODO: after computing pose uncomment this section
        raux.convertTo(Rvec,CV_32F);
        taux.convertTo(Tvec ,CV_32F);

        cv::Mat_<float> rotMat(3,3);
        cv::Rodrigues(Rvec, rotMat);

        // Copy to transformation matrix
        for (int col=0; col<3; col++)
        {
            for (int row=0; row<3; row++)
            {
                m.pose.setRotation(Rvec);
            }
            m.pose.setTranslation(Tvec);
        }

        // SECTION end


    }
}

float  MarkerDetectorBW::perimeter(const std::vector<cv::Point2f> &a)
{
    float sum = 0, dx, dy;

    for (size_t i = 0; i<a.size(); i++)
    {
        size_t i2 = (i + 1) % a.size();

        dx = a[i].x - a[i2].x;
        dy = a[i].y - a[i2].y;

        sum += sqrt(dx*dx + dy*dy);
    }

    return sum;
}


bool  MarkerDetectorBW::isInto(cv::Mat &contour, std::vector<cv::Point2f> &b)
{
    for (size_t i = 0; i<b.size(); i++)
    {
        if (cv::pointPolygonTest(contour, b[i], false)>0) return true;
    }
    return false;
}
